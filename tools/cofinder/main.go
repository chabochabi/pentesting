package main

import(
	"fmt"
	"os"
	"flag"
	"path/filepath"
	"io/ioutil"
	"regexp"
	"strings"
)

type file struct {
	path string
	info os.FileInfo
}

// TODO path could be a file struct to include file info
type fileComments struct {
	path string
	comments []string
}

// add or remove files as you like
var fileTypes = [6]string{".c", ".cc", ".cpp", ".java", ".go", ".php"}

// regex for c/c++, java, go, php, etc.
var cRegex = "()\\/\\*([^*]|[\\r\\n]|(\\*+([^*\\/]|[\r\n])))*\\*\\/|([\\s]*\\/\\/.*)"

// error check
func check(e error) {
	if e != nil {
		panic(e)
	}
}


func printResults(fc fileComments, tr bool, l int) {

	fmt.Println("\n\n###############################################################################")
	fmt.Println("#")
	fmt.Println("# file: ", fc.path)
	fmt.Println("#")
	fmt.Println("###############################################################################")
	for _, c := range fc.comments {
		// TODO filter comments in the finding phase, not the presentation
		trimmed := strings.TrimSpace(c)
		// TODO: +2 is only to remove '//', this is a temporary solution
		if len(trimmed) >= l+2 {
			fmt.Printf("--------------------------------------------------------------\n\n")
			if tr {
				fmt.Printf("%s\n\n", trimmed)
			} else {
				fmt.Printf("%s\n\n", c)
			}
			fmt.Printf("--------------------------------------------------------------\n")
		}
	}
}

// recursive directory listing
func recList(root string) (files []file){
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		files = append(files, file {path: path, info: info})
		return nil
	})
	if err != nil {
		panic(err)
	}

	return files
}

// check if path is a directory
func isDir(path string) bool {
	fi, err := os.Stat(path)
	check(err)
	if fi.Mode().IsDir() {
		return true
	}
	return false
}

// find all comments in a file using a globally define regex
func findComments(f file) (fc fileComments){

	fc.path = f.path

	if isDir(f.path) {
		return
	}

	data, err := ioutil.ReadFile(f.path)
	check(err)
	content := string(data)
	r,err := regexp.Compile(cRegex)
	check(err)
	match := r.FindAllString(content, -1)
	for _, m := range match {
		fc.comments = append(fc.comments, m)
	}

	return fc
}

// check if file extension is a valid one to exclude irrelevant files
func validFile(ext string) bool {
	for _, ft := range fileTypes {
		if ext == ft {
			return true
		}
	}
	return false
}

// recursive search for valid files
func recFinder(root string) (all []fileComments){
	var files = recList(root)

	for _, f := range files {
		if validFile(filepath.Ext(f.path)) {
			all = append(all,findComments(f))
		}
	}

	return all
}

// run single file comment search
func singleFinder(path string) (fc fileComments){
	fi,err := os.Stat(path)
	check(err)
	fc = findComments(file {path: path, info: fi})
	return fc
}

func main() {

	var (
		rootFolder string
		singleFile string
		trimSpaces bool
		minLength int
	)

	flag.StringVar(&rootFolder, "d", "", "root folder for recursive search")
	flag.StringVar(&singleFile, "f", "", "search in a single file")
	flag.BoolVar(&trimSpaces, "tr", false, "trim leading and trailing spaces from comments")
	flag.IntVar(&minLength, "l", 2, "set minimin length for comments, after trim")

	flag.Parse()

	// run a recursive comment search for given root dir
	if rootFolder != "" {
		fmt.Println("[*] running cofinder in recursive mode with root folder: ", rootFolder)
		all := recFinder(rootFolder)
		fmt.Printf("[*] these are all the comments that were found:\n\n\n")
		for _, fc := range all {
			if (len(fc.comments) > 0) {
				printResults(fc, trimSpaces, minLength)
			}
		}
	} else if singleFile != "" { // run a comment search for a single file
		fmt.Println("[*] running cofinder on a single file: ", singleFile)
		fc := singleFinder(singleFile)
		printResults(fc, trimSpaces, minLength)
	}
}
