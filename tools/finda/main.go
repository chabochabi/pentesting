package main

import(
	"fmt"
	"os"
	"flag"
	"path/filepath"
	"io/ioutil"
	"regexp"
	"encoding/base64"
	"unicode"
)

var ASCIIChar = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x0020, 0x007F, 1},
	},
}

type file struct {
	path string
	info os.FileInfo
}

// TODO path could be a file struct to include file info
type finding struct {
	path string
	findings []string
}

// add or remove files as you like
var fileTypes = [6]string{".c", ".cc", ".cpp", ".java", ".go", ".php"}

// finding SQL selects 
//var cRegex = "(select|SELECT)\\s*.*\\s*(FROM|from).*"
var cRegex = "[^A-Za-z0-9+/][a-zA-Z0-9+/]+={0,2}"

// error check
func check(e error) {
	if e != nil {
		panic(e)
	}
}


func printResults(fnd finding, l int) {

	fmt.Println("\n\n###############################################################################")
	fmt.Println("#")
	fmt.Println("# file: ", fnd.path)
	fmt.Println("#")
	fmt.Println("###############################################################################")
	for _, c := range fnd.findings {
		// TODO filter findings in the finding phase, not the presentation
		// TODO: +2 is only to remove '//', this is a temporary solution
		if len(c) >= l+2 {
			fmt.Printf("--------------------------------------------------------------\n\n")
			fmt.Printf("%s\n\n", c)
			fmt.Printf("--------------------------------------------------------------\n")
		}
	}
}

// recursive directory listing
func recList(root string) (files []file){
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		files = append(files, file {path: path, info: info})
		return nil
	})
	if err != nil {
		panic(err)
	}

	return files
}

// check if path is a directory
func isDir(path string) bool {
	fi, err := os.Stat(path)
	check(err)
	if fi.Mode().IsDir() {
		return true
	}
	return false
}

// find all findings in a file using a globally define regex
func finda(f file) (fnd finding){

	fnd.path = f.path

	if isDir(fnd.path) {
		return
	}

	data, err := ioutil.ReadFile(fnd.path)
	check(err)
	content := string(data)
	r,err := regexp.Compile(cRegex)
	check(err)
	match := r.FindAllString(content, -1)
	for _, m := range match {
		if (len(m)-1)%4 != 0 {
			continue
		}
		decb, _ := base64.StdEncoding.DecodeString(m[1:])
		decoded := string(decb)
		if decoded == "" {
			continue
		}

		containsNonASCII := false
		for _, r := range decoded {
			if !unicode.Is(ASCIIChar, r) {
				containsNonASCII = true
				break
			}
		}
		if containsNonASCII {
			continue
		}

		//decoded = strings.Replace(decoded, "\n", " ", -1)
		fnd.findings = append(fnd.findings, decoded)
	}

	return fnd
}

// check if file extension is a valid one to exclude irrelevant files
func validFile(ext string) bool {
	for _, ft := range fileTypes {
		if ext == ft {
			return true
		}
	}
	return false
}

// recursive search for valid files
func recFinder(root string) (all []finding){
	var files = recList(root)

	for _, f := range files {
		all = append(all,finda(f))
	}

	return all
}

// run single file comment search
func singleFinder(path string) (fnd finding){
	fi,err := os.Stat(path)
	check(err)
	fnd = finda(file {path: path, info: fi})
	return fnd
}

func main() {

	var (
		rootFolder string
		singleFile string
		minLength int
	)

	flag.StringVar(&rootFolder, "d", "", "root folder for recursive search")
	flag.StringVar(&singleFile, "f", "", "search in a single file")
	flag.IntVar(&minLength, "l", 2, "set minimin length for findings, after trim")

	flag.Parse()

	// run a recursive comment search for given root dir
	if rootFolder != "" {
		fmt.Println("[*] running cofinder in recursive mode with root folder: ", rootFolder)
		all := recFinder(rootFolder)
		fmt.Printf("[*] these are all the findings that were found:\n\n\n")
		for _, fnd := range all {
			if (len(fnd.findings) > 0) {
				printResults(fnd, minLength)
			}
		}
	} else if singleFile != "" { // run a comment search for a single file
		fmt.Println("[*] running cofinder on a single file: ", singleFile)
		fnd := singleFinder(singleFile)
		printResults(fnd, minLength)
	}
}
